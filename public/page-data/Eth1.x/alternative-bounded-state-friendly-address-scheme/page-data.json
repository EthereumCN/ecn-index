{"componentChunkName":"component---src-template-article-js","path":"/Eth1.x/alternative-bounded-state-friendly-address-scheme/","result":{"data":{"strapiArticles":{"title":"另一个状态友好的界地址方案","summary":"Vitalik 提出了适用于 state expiry 机制的地址方案","publishDate":"2021-06-30","author":"Vitalik Buterin","authorImg":{"childImageSharp":{"fixed":{"src":"/static/515d00ee55c5d2ee181737cd9a0360fa/8cf18/ce0b14e38f1e7a91610a9ba0f696437a.jpg"}}},"content":"来源 | [ethresear.ch](https://ethresear.ch/t/alternative-bounded-state-friendly-address-scheme/8602)\n\n\n译者按：本文需要读者对状态管理和 state expiry 机制作一定了解，以下为推荐阅读：\n\n[以太坊状态管理诸提议](https://mp.weixin.qq.com/s/fEEHT3bmcqXEfqFCGiOpFg)\n\n[状态膨胀和无状态性](https://mp.weixin.qq.com/s/lLOaplyoYL2dR6Bc7XYWJA)\n\n[一份新的无状态以太坊路线图](https://mp.weixin.qq.com/s/iJCTOcYEsXXmFq-_P55qhg) \n\n[弱无状态性以及/或者状态保质期机制：即将到来](https://mp.weixin.qq.com/s/zeVmefqeBUN-QLx8-Q3auw) \n\n感谢 EthFans 的翻译\n\n\n# 回顾：状态大小管理技术\n\n为了防止以太坊的状态容量无止境地膨胀，我们需要用一些方法使旧状态“失活”,这样加入网络的节点就不再需要存储旧状态了。即使大多数的客户端都变成无状态，似乎也可以合理预见，最终这个系统会扩容到网络无法一直保证所有状态都可用的地步。有两个方法可以使旧状态失活：\n\n1. 直接删掉，然后可以把它移到另外的默克尔树，这样关心该状态对象的人可以获取相应的默克尔分支，在未来某个时候用它来激活该状态。\n2. 不把对象移出树结构；相反，只在树的该位置标记“失活”，这样节点就不会存储它 (且协议也不会要求它们这样做)。通过发送一个提供默克尔证明 (即见证数据) 的事务来访问该状态，失活的对象就可以重新被访问了。\n\n方法 (1) 对应于“经典的存储租金方案”，方法 (2) 对应于传统“无状态客户端”的最简单延伸——旧状态可以被遗忘的模型。这两种方法都允许关心特定状态对象的个人追踪默克尔分支，这样随后如果那些状态对象失活了它们可以用来激活这些对象。然而，这两种方法都是有明显问题的。\n\n当要在某个已失效合约的同一个地址上再创建合约时，方法 (1) 会出现一些极端情况。那就是，如果一个合约在地址 A 上创建了，然后已经失效了，那么在地址 A 上创建这个合约的事务会被重新执行，这样会在地址 A 上创建一个新对象，这会影响原始对象的激活。另一种情况是当在地址 A 上创建了一个对象，然后经历失活、被激活、被修改 (例如，发送合约上的资金到另一个账户)、再失活、再用第一次失活所在的默克尔分支激活。这违背了保留规则，且可能被用于铸币；需要增加额外的默克尔证明来证明一个合约还没有被另一个特定状态激活，而该状态也尝试被激活。\n\n\n方法 (2) 遇到的是不同的问题。假设两个相邻的地址 (也就是两者间没有对象) A1 和 A2 都已失活。这样，不仅 A1 和 A2 都不再可以访问 (除非有人存储了默克尔分支)，而且 A1 和 A2 之间的所有地址都不可以访问了。也就是说，如果总共有 N 个地址，那么大约 1/N 的可用地址空间都不再可访问了。当一半的地址都失活了，大约 1/4 的地址空间不再可访问。随着时间推移，会越来越难找到空间生成新的地址。而且由于新地址越来越集中在剩下的“可访问”空间上，每 N 年可访问空间减半的这种影响会呈指数增长。\n\n# 提议\n\n\n我提议对方法 (2) 进行修改，可以解决以上的问题。正如很多方法 (2) 的提议实现方案所呈现的，账户有“活跃”与“失活”两种状态，失活账户是那些超过一年未被访问过的账户。要访问失活账户，你需要提供见证数据；当失活账户被访问了，该账户会自动解除失活状态 (触及任何账户都会重置它的一年失活期计算)。修改内容如下：\n\n- 我们给每个地址添加一个 32 个字节的 \"epoch 前缀\" （会被解译为一个整数）。例如，epoch 前缀是 9 的地址是这样：<ilc>0x00000009de0b295669a9fd93d5f28d9ec85e40f4cb697bae</ilc>，以 <ilc>00000009</ilc> 作为前缀。\n- 默克尔路径会直接依赖 epoch 的前缀而不是它的哈希值 (因此 <ilc>merkle_path_key = address[:4] + hash(address[4:]</ilc>) 而不是现在在用的<ilc>merkle_path_key = hash(address)</ilc> 。这确保了“没用过的”地址空间是连续的。\n- 除非地址的 epoch 前缀是小于或等于区块链已运行的年数，否则地址不能被使用\n- 会增加一个 CREATE3 操作码，它会把 epoch 前缀作为一个参数，并在具有该 epoch 前缀的一个地址上创建一个合约。\n\n\n推荐用户和合约总是使用具有尽可能新的 epoch 前缀来创建账户，甚至设为默认设置，因为肯定会有具有最新 epoch 前缀的全状态仍然是可以访问的。为了还能保有“反事实地址 (counterfactual addresses)”（即在合约代码被发布前，用户在链上 [例如通过发送 ETH 或 ERC20 代币]或链下[通过在一个通道里互动]交互的地址），用旧 epoch 前缀来创建合约还是可能的。但是，对于想要创建反事实地址的用户，如果长期不创建，他们就要负责为该账户存储旧状态的分支。\n\n经过多年的运行，预计活跃状态会由两部分构成：(i) 有最新 epoch 前缀的全部地址空间，(ii) 与最近被活跃使用过的账户相对应的特定旧状态\n\n请注意，这个方案正常情况下扩展到合约上；事实上，主动遵循这个方案是符合合约自身运作的。因为在这个方案里，地址中代表存储的部分以几个字节为前缀，它们所代表的数字 N 指的是这些数据是在 N 年与这些地址产生关联。这很适合用于存储像代币余额这样的数据。\n\n\nECN的翻译工作旨在为中国以太坊社区传递优质资讯和学习资源，文章版权归原作者所有，转载须注明原文出处以及ethereum.cn，若需长期转载，请联系eth@ecn.co进行授权。","cover":{"childImageSharp":{"resize":{"src":"/static/d44558de9332e47aa06f734f7e2f1039/497c6/100f64db9911ecadb5839492c020a385.png"}}}},"site":{"siteMetadata":{"title":"Ethereum Community Network","description":"以太坊——全球的、开源的去中心化应用平台。DeFi？NFT？游戏？虚拟世界？每一个人都可以成为以太坊的开发者和用户！","author":"@ECN以太坊社区网络","keywords":"以太坊,以太坊中国,Ethereum","siteLanguage":"zh-CN","siteLocale":"zh-cn","siteUrl":"http://ethereum.cn","twitterUsername":"@EthereumCN"}}},"pageContext":{"id":"Articles_297"}},"staticQueryHashes":["1238767529","2940180826"]}